Savory Orange Tortoise

Medium

# EIP-712 incompiliance in CDS.sol

### Summary

According to README, codebase expected to comply with EIP-712:
>Is the codebase expected to comply with any specific EIPs?
We have used EIP-712 for verifying sign

But `_verify()` function incorrectly hashes `bytes memory odosExecutionData` variable, leading to wrong digest hash.

### Root Cause

[Link](https://github.com/sherlock-audit/2024-11-autonomint/blob/0d324e04d4c0ca306e1ae4d4c65f0cb9d681751b/Blockchain/Blockchian/contracts/Core_logic/CDS.sol#L899-L906)

According to [EIP-712](https://eips.ethereum.org/EIPS/eip-712#definition-of-encodedata)
>The dynamic values `bytes` and `string` are encoded as a `keccak256` hash of their contents.

Dynamic types must be first hashed with `keccak256` to become one 32-byte word before being encoded and hashed together with the typeHash and the other values.

However, the `_verify()` function in the `CDS.sol` contract reconstructs the digest by encoding the ï»¿`odosExecutionData` bytes argument without first applying `keccak256` hashing:
```solidity
digest = _hashTypedDataV4(
                keccak256(
                    abi.encode(
                        keccak256("OdosPermit(bytes odosExecutionData)"),
                        odosExecutionData
                    )
                )
            );
```


### Internal pre-conditions

`functionName == FunctionName.BORROW_WITHDRAW`

### External pre-conditions

_No response_

### Attack Path

The issue can happen naturally

### Impact

A signature generated by the signer using common EIP712 tools would not pass validation in `_verify()`.


### PoC

_No response_

### Mitigation

```diff
digest = _hashTypedDataV4(
                keccak256(
                    abi.encode(
                        keccak256("OdosPermit(bytes odosExecutionData)"),
-                        odosExecutionData
+                        keccak256(odosExecutionData)
                    )
                )
            );
```