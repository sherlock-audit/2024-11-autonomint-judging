Fantastic Taupe Tortoise

High

# Loss of funds on `CDS.redeemUSDT`

### Summary


The flow of [CDS.redeemUSDT](https://github.com/sherlock-audit/2024-11-autonomint/blob/0d324e04d4c0ca306e1ae4d4c65f0cb9d681751b/Blockchain/Blockchian/contracts/Core_logic/CDS.sol#L508-L523) --> [CDSLib.redeemUSDT](https://github.com/sherlock-audit/2024-11-autonomint/blob/0d324e04d4c0ca306e1ae4d4c65f0cb9d681751b/Blockchain/Blockchian/contracts/lib/CDSLib.sol#L404) allows to swap usda into `usdt`. But user can extract all the available `usdt` with just 1 wei of `usda` amount.



### Root Cause



Not validating the `usdaPrice` and `usdtPrice` during USDT redemption


### Internal pre-conditions

_No response_

### External pre-conditions

_No response_

### Attack Path



All that user has to do is call [CDS.redeemUSDT](https://github.com/sherlock-audit/2024-11-autonomint/blob/0d324e04d4c0ca306e1ae4d4c65f0cb9d681751b/Blockchain/Blockchian/contracts/Core_logic/CDS.sol#L508-L523) with `usdaAmount` = 1 wei, maximum possible `usdaPrice`, and minimum possible `usdtPrice` according to the maximum possible USDT balance.
The amount of USDT to send depends on `usdtAmount = ((usdaPrice * usdaAmount) / usdtPrice)`. So, the numerator can be manipulated by calling with maximum `usdaPrice` value. And this way, allowing users to extract or snipe all the USDT from system causes loss of funds.

[CDS.redeemUSDT](https://github.com/sherlock-audit/2024-11-autonomint/blob/0d324e04d4c0ca306e1ae4d4c65f0cb9d681751b/Blockchain/Blockchian/contracts/Core_logic/CDS.sol#L508-L523)
[CDSLib.redeemUSDT](https://github.com/sherlock-audit/2024-11-autonomint/blob/0d324e04d4c0ca306e1ae4d4c65f0cb9d681751b/Blockchain/Blockchian/contracts/lib/CDSLib.sol#L404)

```solidity
    function redeemUSDT(
        uint128 usdaAmount,
        uint64 usdaPrice,
        uint64 usdtPrice
    ) external payable nonReentrant whenNotPaused(IMultiSign.Functions(6)) {
        burnedUSDaInRedeem = CDSLib.redeemUSDT(
            Interfaces(
                treasury,
                globalVariables,
                usda,
                usdt,
                borrowing,
                CDSInterface(address(this))
            ),
            burnedUSDaInRedeem,
            usdaAmount,
  @@        usdaPrice,
  @@        usdtPrice
        );

        // getting options since,the src don't know the dst state
        bytes memory _options = OptionsBuilder.newOptions().addExecutorLzReceiveOption(400000, 0);

        // calculting fee
        MessagingFee memory fee = globalVariables.quote(
            IGlobalVariables.FunctionToDo(1),
            IBorrowing.AssetName(0),
            _options,
            false
        );

        // Calling Omnichain send function
        globalVariables.send{value: fee.nativeFee}(
            IGlobalVariables.FunctionToDo(1),
            IBorrowing.AssetName(0),
            fee,
            _options,
            msg.sender
        );
    }


    function redeemUSDT(
        CDSInterface.Interfaces memory interfaces,
        uint256 burnedUSDaInRedeem,
        uint128 usdaAmount,
        uint64 usdaPrice,
        uint64 usdtPrice
    ) external returns (uint256) {
        // CHeck the usdaAmount is non zero
        if (usdaAmount == 0) revert CDSInterface.CDS_NeedsMoreThanZero();
        // Check the user has enough usda balance
        if (interfaces.usda.balanceOf(msg.sender) < usdaAmount)
            revert CDSInterface.CDS_Insufficient_USDa_Balance();
        // Increment burnedUSDaInRedeem
        burnedUSDaInRedeem += usdaAmount;
        // GET the omnichain data
        IGlobalVariables.OmniChainData memory omniChainData = interfaces.globalVariables.getOmniChainData();
        // Increment burnedUSDaInRedeem
        omniChainData.burnedUSDaInRedeem += usdaAmount;
        // burn usda
        bool transfer = interfaces.usda.burnFromUser(msg.sender, usdaAmount);
        if (!transfer) revert CDSInterface.CDS_TransferFailed(IBorrowing.AssetName.USDa);
        // calculate the USDT USDa ratio
  @@    uint128 usdtAmount = ((usdaPrice * usdaAmount) / usdtPrice);

        interfaces.treasury.approveTokens(IBorrowing.AssetName.TUSDT, address(interfaces.cds), usdtAmount);
        // Transfer usdt to user
        bool success = interfaces.usdt.transferFrom(
            address(interfaces.treasury),
            msg.sender,
            usdtAmount
        );
        if (!success) revert CDSInterface.CDS_TransferFailed(IBorrowing.AssetName.TUSDT);

        interfaces.globalVariables.setOmniChainData(omniChainData);

        return burnedUSDaInRedeem;
    }
```



### Impact


Loss of funds with no external or internal condition. As soon as USDT is available to redeem, the attackers will snipe these amounts.


### PoC

_No response_

### Mitigation




Validate the `usda` and `usdt` prices
